1.Python program to check if a binary tree is BST or not
INT_MAX = 4294967296
INT_MIN = -4294967296

class Node: 
    def __init__(self, data): 
        self.data = data  
        self.left = None
        self.right = None
   
def isBST(node): 
    return (isBSTUtil(node, INT_MIN, INT_MAX)) 
def isBSTUtil(node, mini, maxi): 
      
    if node is None: 
        return True
  
    if node.data < mini or node.data > maxi: 
        return False
  
    return (isBSTUtil(node.left, mini, node.data -1) and
          isBSTUtil(node.right, node.data+1, maxi)) 
 
root = Node(4) 
root.left = Node(2) 
root.right = Node(5) 
root.left.left = Node(1) 
root.left.right = Node(3) 
  
if (isBST(root)): 
    print "Is BST"
else: 
    print "Not a BST"



2.Write a C Program to perform the following operations on Triply Linked List
struct Node 
{ 
  int data; 
  struct Node *next; 
}; 
void push(struct Node** head_ref, int new_data) 
{ 
    struct Node* new_node = (struct Node*) malloc(sizeof(struct Node)); 
   
    
    new_node->data  = new_data; 
   
    
    new_node->next = (*head_ref); 
   
    
    (*head_ref)    = new_node; 
} 

void insertAfter(struct Node* prev_node, int new_data) 
{ 
    
    if (prev_node == NULL)  
    {  
       printf("the given previous node cannot be NULL");        
       return;   
    }   
           
    struct Node* new_node =(struct Node*) malloc(sizeof(struct Node)); 
   
    new_node->data  = new_data; 
   
    new_node->next = prev_node->next;  
   
    prev_node->next = new_node; 
} 

void append(struct Node** head_ref, int new_data) 
{ 
   
    struct Node* new_node = (struct Node*) malloc(sizeof(struct Node)); 
  
    struct Node *last = *head_ref;  /* used in step 5*/
   
    
    new_node->data  = new_data; 
  
   
    new_node->next = NULL; 
  
    
    if (*head_ref == NULL) 
    { 
       *head_ref = new_node; 
       return; 
    }   
       
    
    while (last->next != NULL) 
        last = last->next; 
   
    last->next = new_node; 
    return;     
} 
#include <stdio.h> 
#include <stdlib.h> 
  

struct Node 
{ 
    int data; 
    struct Node *next; 
}; 
  

void push(struct Node ** head_ref, int new_data) 
{ 
   
    struct Node* new_node = (struct Node*) malloc(sizeof(struct Node)); 
  
    
    new_node->data  = new_data; 
  
    
    new_node->next = (*head_ref); 
  
    
    (*head_ref)  = new_node; 
} 
  

void printList(struct Node *head) 
{ 
    struct Node *temp = head; 
    while (temp != NULL) 
    { 
        printf("%d ", temp->data); 
        temp = temp->next; 
    } 
    printf("\n"); 
} 
  

void skipMdeleteN(struct Node  *head, int M, int N) 
{ 
    struct Node *curr = head, *t; 
    int count; 
  
    
    while (curr) 
    { 
         
        for (count = 1; count<M && curr!= NULL; count++) 
            curr = curr->next; 
  
        
        if (curr == NULL) 
            return; 
  
       
        t = curr->next; 
        for (count = 1; count<=N && t!= NULL; count++) 
        { 
            struct Node *temp = t; 
            t = t->next; 
            free(temp); 
        } 
        curr->next = t; // Link the previous list with remaining nodes 
  
        curr = t; 
    } 
} 
 
int main() 
{ 
    struct Node* head = NULL; 
    int M=2, N=3; 
    push(&head, 10); 
    push(&head, 9); 
    push(&head, 8); 
    push(&head, 7); 
    push(&head, 6); 
    push(&head, 5); 
    push(&head, 4); 
    push(&head, 3); 
    push(&head, 2); 
    push(&head, 1); 
  
    printf("M = %d, N = %d \nGiven Linked list is :\n", M, N); 
    printList(head); 
  
    skipMdeleteN(head, M, N); 
  
    printf("\nLinked list after deletion is :\n"); 
    printList(head); 
  
    return 0; 
} 